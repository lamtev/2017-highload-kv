# Нагрузочное тестирование

## Параметры машины, ОС и инструменты

Тестрирование полностью производилось на машине с 2-х ядерным процессором Intel Core i5-4200H 2.8 ГГц, на котором 4 логических процессора. Память - 8 ГБ. Диск - SSD SATA 6 Гб/c.

3 инстанса БД запускались на __localhost__ (порты 8081, 8082, 8083) на __Windows 10__ на __jre-9.0.1__.

Нагрузка подавалась при помощи инструмента __[yandex-tank](http://yandextank.readthedocs.io/en/latest/index.html)__ ([__overload__](https://overload.yandex.net/)), запущенного в виртуальной машине с __Ubuntu 16.04.3 LTS__, которой было выделено 4 вируальных процессора и 2 ГБ памяти.

## Подготовка нагрузки

Для генерации патронов использовался [готовый py скрипт](http://yandextank.readthedocs.io/en/latest/ammo_generators.html)  из туториала, который принимает на вход строки вида `GET||/url||case_tag||body(optional)`.

Самостоятельно был написан [py скрипт](https://github.com/lamtev/2017-highload-kv/blob/master/yandex-tank/ammo_gens/gen_data.py) для генерации данных, подающихся на вход генератора патронов. Данный скрипт позволяет создать файл с `N` (только `PUT`, только `GET`, смесь `PUT` и `GET`) запросами с/без перезаписи и `replicas=K/M`.

Далее были сгенерированы патроны для всех случаев, описанных в [задании](https://github.com/lamtev/2017-highload-kv#%D0%9D%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0).

## Тестирование

### Описание первой реализации БД.

__Исходный проект__ был примерно таким: для обработки нодой запросов `/v0/entity?...` от клиента использовался `newFixedThreadPool()` с 5-ю потоками. Запросы между нодами обрабатывались при помощи `newSingleThreadExecutor()`, т.к. такие запросы подразумевали чтение и запись с/на диск. После того, как запрос приходил на ноду в `newSingleThreadExecutor()`, пораждалось еще столько потоков, сколько нод в кластере, чтобы нода могла отправлять данные на другие ноды параллельно. Осуществлено это было при помощи механизма асинхронной работы `Future`. Нода запросы на другие ноды отправляла параллельно, а ответы принимала последовательно.

### Подача нагрузки

Было определено, что БД выдерживает нагрузку примерно 200 `GET` запросов в секунду и  100 `PUT` запросов в секунду. Далее подавалась примерно такая нагрузка с `replicas` `2/3` и `3/3` с/без перезаписи.

Ниже приведена информация о пропускной способности для каждого случая. А более подробная информация с графиками доступна по соответстующим ссылкам.

* GET 3/3 без перезаписи
  * 1 поток соединения - 181 rps ([ссылка на overload](https://overload.yandex.net/72741))
  * 2 потока соединения - 205 rps ([ссылка на overload](https://overload.yandex.net/72743))
  * 4 потока соединения - 258 rps ([ссылка на overload](https://overload.yandex.net/72745))
* GET 3/3 с перезаписью
  * 1 поток соединения - 191 rps ([ссылка на overload](https://overload.yandex.net/72784))
  * 2 потока соединения - 210 rps ([ссылка на overload](https://overload.yandex.net/72783))
  * 4 потока соединения - 225 rps ([ссылка на overload](https://overload.yandex.net/72785))
* GET 2/3 без перезаписи
  * 1 поток соединения - 211 rps ([ссылка на overload](https://overload.yandex.net/72742))
  * 2 потока соединения - 247 rps ([ссылка на overload](https://overload.yandex.net/72744))
  * 4 потока соединения - 325 rps ([ссылка на overload](https://overload.yandex.net/72747))
* GET 2/3 с перезаписью
  * 1 поток соединения - 225 rps ([ссылка на overload](https://overload.yandex.net/72786))
  * 2 потока соединения - 269 rps ([ссылка на overload](https://overload.yandex.net/72789))
  * 4 потока соединения - 273 rps ([ссылка на overload](https://overload.yandex.net/72790))
  
* PUT 3/3 без перезаписи
  * 1 поток соединения - 46 rps ([ссылка на overload](https://overload.yandex.net/72792))
  * 2 потока соединения - 77 rps ([ссылка на overload](https://overload.yandex.net/72793))
  * 4 потока соединения - 44 rps ([ссылка на overload](https://overload.yandex.net/72798))
* PUT 3/3 с перезаписью
  * 1 поток соединения - 67 rps ([ссылка на overload](https://overload.yandex.net/72808))
  * 2 потока соединения - 82 rps ([ссылка на overload](https://overload.yandex.net/72809))
  * 4 потока соединения - 93 rps ([ссылка на overload](https://overload.yandex.net/72810))
* PUT 2/3 без перезаписи
  * 1 поток соединения - 67 rps ([ссылка на overload](https://overload.yandex.net/72799))
  * 2 потока соединения - 67 rps ([ссылка на overload](https://overload.yandex.net/72802))
  * 4 потока соединения - 66 rps ([ссылка на overload](https://overload.yandex.net/72804))
* PUT 2/3 с перезаписью
  * 1 поток соединения - 71 rps ([ссылка на overload](https://overload.yandex.net/72811))
  * 2 потока соединения - 83 rps ([ссылка на overload](https://overload.yandex.net/72812))
  * 4 потока соединения - 74 rps ([ссылка на overload](https://overload.yandex.net/72813))
  
* PUTGET 3/3 без перезаписи
  * 4 потока соединения - 98 rps ([ссылка на overload](https://overload.yandex.net/72814))
* PUTGET 3/3 с перезаписью
  * 4 потока соединения - 125 rps ([ссылка на overload](https://overload.yandex.net/72817))
* PUTGET 2/3 без перезаписи
  * 4 потока соединения - 109 rps ([ссылка на overload](https://overload.yandex.net/72815))
* PUTGET 2/3 с перезаписью
  * 4 потока соединения - 114 rps ([ссылка на overload](https://overload.yandex.net/72822))
  
### Описание оптимизаций.

Было решено, что слабые места в первой реализации это:

1. Использование `newSingleThreadExecutor()` при обработке запросов, которые пишут/читают на/с диска.
2. Последовательная обработка ответов от других нод.

В исправленном варианте используется `StampedLock` для умной блокировки на запись/чтение и для _оптимистичного чтения_, если запись происходит редко. И вместо однопоточного пула используется `newFixedThreadPool()` с числом потоков равному `Runtime.getRuntime().availableProcessors() + 1`.

Вместо `Future` используются `CompletableFuture`, которые засчёт колбэков позволяют легко асинхронно обрабатывать ноде ответы от других нод.

### Подача нагрузки

По схожему принципу подавалась нагрузка. Пропускная способность выросла в среднем на 30%. Ниже приведены некоторые ссылки на результаты тестирования.

* [ссылка](https://overload.yandex.net/73455)
* [ссылка](https://overload.yandex.net/73459)
* [ссылка](https://overload.yandex.net/73461)
* [ссылка](https://overload.yandex.net/73463)

### Выводы
Проводить тестирование в таком окружении (БД на host os, а yandex-tank на guest os) было не очень просто. Возникали различные проблемы. И результаты, полученные до и после оптимизаций, кажутся весьма невысокими. Далее в свободное время планируется запустить приложение на разных машинах. И возможно, даже на линуксе, чтобы была возможность профилировать в `jvisualvm` (на windows нет поддержки профилирования локальных процессов). И посмотреть как разработанная БД поведёт себя в более боевых условиях.

С другой стороны, был получен опыт настройки и использования инструмента `yandex-tank`, а также были изучены разные механизмы асинхронных вычислений на `java`. В целом было интересно.
